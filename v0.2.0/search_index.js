var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PartonDensity]","category":"page"},{"location":"api/#PartonDensity.input_pdf_map","page":"API","title":"PartonDensity.input_pdf_map","text":"input_pdf_map\n\nThe relevant mapping for use with QCDNUM and get_input_pdf_func.\n\n\n\n\n\n","category":"constant"},{"location":"api/#PartonDensity.AbstractPDFParams","page":"API","title":"PartonDensity.AbstractPDFParams","text":"abstract type PartonDensity.AbstractPDFParams\n\nAbstract type for any PDF parametrisation.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.BernsteinDirichletPDFParams","page":"API","title":"PartonDensity.BernsteinDirichletPDFParams","text":"struct BernsteinDirichletPDFParams <: AbstractPDFParams\n\nBernstein polynomial specification of input PDF parameters. Dirichlet-style treament. \n\nConstructors:\n\nBernsteinDirichletPDFParams(; fields...)\n\nFields:\n\nparam_type::Int64: Default: BERNSTEINDIRICHLETTYPE\nseed::Int64: Default: 0\nweights::Vector{Float64}: Default: ones(9)\nθ::Vector{Float64}: Default: rand(MersenneTwister(seed), Dirichlet(weights))\nbspoly_params::Vector{Vector{Int64}}: Default: [[0, 3], [0, 4], [1, 4]]\nbspoly_params_d::Vector{Vector{Int64}}: Default: bspoly_params\ninitial_U::Vector{Float64}: Default: ones(length(bspoly_params) - 2)\ninitial_D::Vector{Float64}: Default: ones(length(bspolyparamsd) - 2)\nU_list::Vector{Float64}: Default: getUDlist(θ[1], 2, initialU, bspolyparams)\nD_list::Vector{Float64}: Default: getUDlist(θ[2], 1, initialD, bspolyparams_d)\nλ_g1::Float64\nλ_g2::Float64\nK_g::Float64\nλ_q::Float64\nK_q::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.BernsteinPDFParams","page":"API","title":"PartonDensity.BernsteinPDFParams","text":"struct BernsteinPDFParams <: AbstractPDFParams\n\nBernstein polynomial specification of input PDF parameters. Valence-style treatment. \n\nConstructors:\n\nBernsteinPDFParams(; fields...)\n\nFields:\n\nparam_type::Int64: Default: BERNSTEIN_TYPE\nbspoly_params::Vector{Vector{Int64}}: Default: [[0, 3], [0, 4], [1, 4], [0, 5]]\nbspoly_params_d::Vector{Vector{Int64}}: Default: bspoly_params\nU_weights::Vector{Float64}: Default: zeros(length(bspoly_params))\nD_weights::Vector{Float64}: Default: zeros(length(bspoly_params))\nλ_g1::Float64\nλ_g2::Float64\nK_g::Float64\nλ_q::Float64\nK_q::Float64\nseed::Int64: Default: 0\nweights::Vector{Float64}: Default: ones(7)\nU_list::Vector{Float64}: Default: getdirichletUD(Uweights, 2, seed, bspolyparams)\nD_list::Vector{Float64}: Default: getdirichletUD(Dweights, 1, seed, bspolyparams)\nθ::Vector{Float64}: Default: getdirichletsamples(Ulist, Dlist, seed, weights, bspoly_params)\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.DirichletPDFParams","page":"API","title":"PartonDensity.DirichletPDFParams","text":"struct DirichletPDFParams <: AbstractPDFParams\n\nFull Dirichlet specification of input PDF parameters.\n\nConstructors:\n\nDirichletPDFParams(; fields...)\n\nFields:\n\nparam_type::Int64: Default: DIRICHLET_TYPE\nθ::AbstractVector{T} where T<:Real\nK_u::Real\nλ_u::Real: Default: (θ[1] * (K_u + 1)) / (2 - θ[1])\nK_d::Real\nλ_d::Real: Default: (θ[2] * (K_d + 1)) / (1 - θ[2])\nλ_g1::Real\nλ_g2::Real\nK_g::Real\nλ_q::Real\nK_q::Real\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QuarkCoefficients","page":"API","title":"PartonDensity.QuarkCoefficients","text":"QuarkCoefficients\n\nQuark coefficients for structure function  calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.ValencePDFParams","page":"API","title":"PartonDensity.ValencePDFParams","text":"struct ValencePDFParams <: AbstractPDFParams\n\nValence specification of input PDF parameters.\n\nConstructors:\n\nValencePDFParams(; fields...)\n\nFields:\n\nparam_type::Int64: Default: VALENCE_TYPE\nλ_u::Real\nK_u::Real\nλ_d::Real\nK_d::Real\nλ_g1::Real\nλ_g2::Real\nK_g::Real\nλ_q::Real\nK_q::Real\nθ::AbstractVector{T} where T<:Real\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.Init_sys-Tuple{}","page":"API","title":"PartonDensity.Init_sys","text":"Init_sys()\n\nReads various systematic errors and feeds them for further use\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity._fun_xsec_i-Tuple{Int64, Any, Any}","page":"API","title":"PartonDensity._fun_xsec_i","text":"_fun_xsec_i(ix iq)\n\nInput function for cross section spline. Must be wrapped for interface to SPLINT.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2-Tuple{Int64, Array{Float64}, Array{Float64}}","page":"API","title":"PartonDensity.dd_xsecnc_xq2","text":"dd_xsecnc_xq2(charge, x_bin_cen, q2_bin_cen)\n\nDouble differential cross section for all x and  q2 bins. NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2_i-Tuple{Int64, Float64, Float64, Float64, Float64, Float64}","page":"API","title":"PartonDensity.dd_xsecnc_xq2_i","text":"dd_xsecnc_xq2_i(charge, x, q2)\n\nDouble differential cross section for single  x and q2 values.  NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.f2_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.f2_lo","text":"f2_lo(x, q2)\n\nCalculate the f2_lo structure function term.  To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.fl_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.fl_lo","text":"fl_lo(x, q2)\n\nCalculate the fl_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.forward_model","page":"API","title":"PartonDensity.forward_model","text":"forward_model(pdf_params, qcdnum_grid, \n              splint_params, quark_coeffs, sys_err_params)\n\nGo from input PDF parameters to the expected number of events in bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.forward_model_init-Tuple{QCDNUM.EvolutionParams, QCDNUM.SPLINTParams}","page":"API","title":"PartonDensity.forward_model_init","text":"forward_model_init(qcdnum_grid, qcdnum_params)\n\nInitialise forward model. Initialises QCDNUM and builds weight tables to  save time in subsequent iterations. Must be called prior to first instance  of forward_model().\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.get_bin_info-Tuple{Integer}","page":"API","title":"PartonDensity.get_bin_info","text":"get_bin_info(n, quiet)\n\nGet the bin egdes of the ZEUS  detector space for a given  bin number, n.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.get_likelihood","page":"API","title":"PartonDensity.get_likelihood","text":"get_likelihood(pdf_params)\n\nGet a suitable likelihood for a given PDF parametrisation.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.get_prior","page":"API","title":"PartonDensity.get_prior","text":"get_prior(pdf_params)\n\nGet a suitable prior for a given PDF parametrisation.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.get_scaled_θ-Tuple{Float64, Float64, Float64, Float64, Vector{Float64}}","page":"API","title":"PartonDensity.get_scaled_θ","text":"get_scaled_θ(λ_u, K_u, λ_d, K_d, θ_tmp)\n\nGiven a set of Dirichlet samples, θ_tmp, scale  according to the valence params. Relevant for  ValencePDFParams.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.get_θ_val-Tuple{Random.AbstractRNG, Float64, Float64, Float64, Float64, Vector{Float64}}","page":"API","title":"PartonDensity.get_θ_val","text":"get_θ_val(rng, λ_u, K_u, λ_d, K_d, weights)\n\nGiven valance shape parameters and weights, get samples θ that are correctly scaled. Relevant for ValencePDFParams \n\nOptional RNG parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.int_xtotx","page":"API","title":"PartonDensity.int_xtotx","text":"int_xtotx(pdf_params)\n\nTotal integrated momentum density. Should equal 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.nc_propagator-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.nc_propagator","text":"nc_propagator(q2, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.pd_read_sim-Tuple{String}","page":"API","title":"PartonDensity.pd_read_sim","text":"pd_read_sim(file_name)\n\nRead in the simulated truth and simulated data from HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.pd_write_sim-Tuple{String, Union{DirichletPDFParams, ValencePDFParams}, Dict{String, Any}}","page":"API","title":"PartonDensity.pd_write_sim","text":"pd_write_sim(file_name, pdf_params, sim_data)\n\nStore the simulation truth and simulated data in an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.plot_data_space","page":"API","title":"PartonDensity.plot_data_space","text":"plot_data_space(pdf_params, sim_data, samples, qcdnum_grid, \n                qcdnum_params, splint_params, quark_coeffs)\n\nCompare truth and posterior samples in the data space.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.plot_model_space","page":"API","title":"PartonDensity.plot_model_space","text":"plot_model_space(pdf_params, samples)\n\nCompare truth and posterior samples in the model space.\n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.rxsecnc_xq2-Tuple{Int64, Array{Float64}, Array{Float64}}","page":"API","title":"PartonDensity.rxsecnc_xq2","text":"rxsecnc_xq2(x, q2)\n\nReduced cross section for all bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.rxsecnc_xq2_i-Tuple{Int64, Float64, Float64, Float64, Float64, Float64}","page":"API","title":"PartonDensity.rxsecnc_xq2_i","text":"rxsecnc_xq2_i(charge, x, q2, F2, xF3, FL)\n\nReduced cross section for single x, q2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_dv_x-Tuple{Real, Real, Real}","page":"API","title":"PartonDensity.x_dv_x","text":"x_dv_x(x, λ_d, K_d)\n\nMomentum density of d valence component. Beta function     Ad x^λd (1 - x)^Kd Ad is set by λd and Kd.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_g_x-NTuple{7, Real}","page":"API","title":"PartonDensity.x_g_x","text":"    x_g_x(x, λ_g1, λ_g2, K_g, K_q, w1, w2)\n\nMomentum density of gluon component.     Ag1 x^λg1 (1 - x)^Kg + Ag2 x^λg2 (1 - x)^Kq Amplitudes are set by weights w1 and w2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_q_x-NTuple{4, Real}","page":"API","title":"PartonDensity.x_q_x","text":"x_q_x(x, λ_q, K_q, w)\n\nMomentum density of non-valence quark component.     Aq x^λq (1 - x)^K_q  Amplitude is set by weight w\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_uv_x-Tuple{Real, Real, Real}","page":"API","title":"PartonDensity.x_uv_x","text":"x_uv_x(x, λ_u, K_u)\n\nMomentum density of u valence component. Beta function      Au x^λu (1-x)^Ku Au is set by λu and Ku.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xf3_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.xf3_lo","text":"xf3_lo(x, q2)\n\nCalculate the xf3_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xtotx","page":"API","title":"PartonDensity.xtotx","text":"x_total_x(x, pdf_params)\n\nTotal momentum density.\n\n\n\n\n\n","category":"function"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/bat_fit_dirichlet_syserr.jl\"","category":"page"},{"location":"bat_fit_dirichlet_syserr/#Fit-with-Dirichlet-parametrisation-and-systematic-errors","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"","category":"section"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"In this example we show how to bring the PDF parametrisation and forward model together with BAT.jl to perform a fit of simulated data.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"This time, we also include the effect of systematic uncertainties. This is done as described in arXiv:2209.06571.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"using PartonDensity\nusing BAT, DensityInterface\nusing QCDNUM\nusing Plots, Random, Distributions, ValueShapes, ParallelProcessingTools\nusing StatsBase, LinearAlgebra\n\ngr(fmt=:png);\nrng = MersenneTwister(42);\n\nweights = [30.0, 15.0, 12.0, 6.0, 3.6, 0.85, 0.85, 0.85, 0.85]\nθ = rand(rng, Dirichlet(weights))\npdf_params = DirichletPDFParams(K_u=4.0, K_d=4.0, λ_g1=1.5, λ_g2=-0.4, K_g=6.0,\n    λ_q=-0.25, K_q=5.0, θ=θ);\n\n@info \"Valence λ:\" pdf_params.λ_u pdf_params.λ_d","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"first specify QCDNUM inputs","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"qcdnum_grid = QCDNUM.GridParams(x_min=[1.0e-3, 1.0e-1, 5.0e-1], x_weights=[1, 2, 2], nx=100,\n    qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\nqcdnum_params = QCDNUM.EvolutionParams(order=2, α_S=0.118, q0=100.0, grid_params=qcdnum_grid,\n    n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\n\nsplint_params = QCDNUM.SPLINTParams();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"We include the effects of systematic errors into the simulation, by sampling from a multivariate normal with mean 0 and standard deviation 1.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"These factors are then applied to a precomputed matrix in order to scale the expected counts accordingly.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"forward_model_init(qcdnum_params, splint_params)\nsys_err_params = rand(rng, MvNormal(zeros(PartonDensity.nsyst), ones(PartonDensity.nsyst)))\ncounts_pred_ep, counts_pred_em = forward_model(pdf_params, qcdnum_params,\n    splint_params, quark_coeffs, sys_err_params);\n\nnbins = size(counts_pred_ep)[1]\ncounts_obs_ep = zeros(UInt64, nbins)\ncounts_obs_em = zeros(UInt64, nbins)\n\nfor i in 1:nbins\n    counts_obs_ep[i] = rand(Poisson(counts_pred_ep[i]))\n    counts_obs_em[i] = rand(Poisson(counts_pred_em[i]))\nend\n\nplot(1:nbins, counts_pred_ep, label=\"Expected counts (eP)\", color=\"blue\")\nplot!(1:nbins, counts_pred_em, label=\"Expected counts (eM)\", color=\"red\")\nscatter!(1:nbins, counts_obs_ep, label=\"Detected counts (eP)\", color=\"blue\")\nscatter!(1:nbins, counts_obs_em, label=\"Detected counts (eM)\", color=\"red\")\nplot!(xlabel=\"Bin number\")\n\nsim_data = Dict{String,Any}()\nsim_data[\"nbins\"] = nbins;\nsim_data[\"counts_obs_ep\"] = counts_obs_ep;\nsim_data[\"counts_obs_em\"] = counts_obs_em;\n\npd_write_sim(\"output/simulation.h5\", pdf_params, sim_data)\nQCDNUM.save_params(\"output/params_dir_sys.h5\", qcdnum_params)\nQCDNUM.save_params(\"output/params_dir_sys.h5\", splint_params)","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"Here, we include a prior over the 8 systematic error parameters, such that we marginalise over them.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"prior = NamedTupleDist(\n    θ=Dirichlet(weights),\n    K_u=Uniform(3.0, 7.0),\n    K_d=Uniform(3.0, 7.0),\n    λ_g1=Uniform(1.0, 2.0),\n    λ_g2=Uniform(-0.5, -0.1),\n    K_g=Uniform(3.0, 7.0),\n    λ_q=Uniform(-0.5, -0.1),\n    K_q=Uniform(3.0, 7.0),\n    beta0_1=Truncated(Normal(0, 1), -5, 5),\n    beta0_2=Truncated(Normal(0, 1), -5, 5),\n    beta0_3=Truncated(Normal(0, 1), -5, 5),\n    beta0_4=Truncated(Normal(0, 1), -5, 5),\n    beta0_5=Truncated(Normal(0, 1), -5, 5),\n    beta0_6=Truncated(Normal(0, 1), -5, 5),\n    beta0_7=Truncated(Normal(0, 1), -5, 5),\n    beta0_8=Truncated(Normal(0, 1), -5, 5)\n);\n\nlikelihood = let d = sim_data\n\n    counts_obs_ep = d[\"counts_obs_ep\"]\n    counts_obs_em = d[\"counts_obs_em\"]\n    nbins = d[\"nbins\"]\n\n    logfuncdensity(function (params)\n\n        pdf_params = DirichletPDFParams(K_u=params.K_u, K_d=params.K_d, λ_g1=params.λ_g1, λ_g2=params.λ_g2,\n            K_g=params.K_g, λ_q=params.λ_q, K_q=params.K_q, θ=Vector(params.θ))\n\n        #The sys_err_params must also be passed to the forward model here.\n        sys_err_params = [params.beta0_1, params.beta0_2, params.beta0_3, params.beta0_4,\n            params.beta0_5, params.beta0_6, params.beta0_7, params.beta0_8]\n\n        counts_pred_ep, counts_pred_em = @critical forward_model(pdf_params,\n            qcdnum_params, splint_params, quark_coeffs, sys_err_params)\n\n        ll_value = 0.0\n        for i in 1:nbins\n            ll_value += logpdf(Poisson(counts_pred_ep[i]), counts_obs_ep[i])\n            ll_value += logpdf(Poisson(counts_pred_em[i]), counts_obs_em[i])\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"Check that we can evaluate the posterior:","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"posterior = PosteriorDensity(likelihood, prior)\nBAT.checked_logdensityof(posterior, rand(prior))","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"We can now run the MCMC sampler. We will start by using the Metropolis-Hastings algorithm as implemented in BAT.jl. To get reasonable results, we need to run the sampler for a long time (several hours). To actually run the sampler, simply uncomment the code below. To see how to work with demo output results, check out the other fit examples.","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"#samples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=2)).result;\n\n#import HDF5\n#bat_write(\"output/results.h5\", samples)","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"","category":"page"},{"location":"bat_fit_dirichlet_syserr/","page":"Fit with Dirichlet parametrisation and systematic errors","title":"Fit with Dirichlet parametrisation and systematic errors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/bat_fit_valence.jl\"","category":"page"},{"location":"bat_fit_valence/#Fit-with-valence-parametrisation","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"In this example we show how to bring the PDF parametrisation and forward model together with BAT.jl to perform a fit of simulated data. This fit is a work in progress and just a starting point for verification of the method.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"using BAT, DensityInterface\nusing PartonDensity\nusing QCDNUM\nusing Plots, Random, Distributions, ValueShapes, ParallelProcessingTools\nusing StatsBase, LinearAlgebra\n\ngr(fmt=:png);\nrng = MersenneTwister(42)","category":"page"},{"location":"bat_fit_valence/#Simulate-some-data","page":"Fit with valence parametrisation","title":"Simulate some data","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We can start off by simulating some fake data for us to fit. This way, we know exactly what initial conditions we have specified and can check the validity of our inference, assuming the generative model is the one that is producing our data.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"This is a good first check to work with.","category":"page"},{"location":"bat_fit_valence/#Specify-the-input-PDFs","page":"Fit with valence parametrisation","title":"Specify the input PDFs","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"See the Input PDF parametrisation and priors example for more information on the definition of the input PDFs. Here, we use the valence parametrisation.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"weights = [5.0, 5.0, 1.0, 1.0, 1.0, 0.5, 0.5]\nλ_u = 0.64;\nK_u = 3.38;\nλ_d = 0.67;\nK_d = 4.73;\nθ = get_θ_val(rng, λ_u, K_u, λ_d, K_d, weights)\npdf_params = ValencePDFParams(λ_u=λ_u, K_u=K_u, λ_d=λ_d, K_d=K_d,\n    λ_g1=0.50, λ_g2=-0.63, K_g=4.23, λ_q=-0.23, K_q=5.0, θ=θ);\n\nplot_input_pdfs(pdf_params)","category":"page"},{"location":"bat_fit_valence/#Go-from-PDFs-to-counts-in-ZEUS-detector-bins","page":"Fit with valence parametrisation","title":"Go from PDFs to counts in ZEUS detector bins","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Given the input PDFs, we can then evolve, calculate the cross sections, and fold through the ZEUS transfer matrix to get counts in bins. Here, we make use of some simple helper functions to do so. For more details, see the Forward model example.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"first specify QCDNUM inputs","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"qcdnum_grid = QCDNUM.GridParams(x_min=[1.0e-3], x_weights=[1], nx=100,\n    qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\nqcdnum_params = QCDNUM.EvolutionParams(order=2, α_S=0.118, q0=100.0, grid_params=qcdnum_grid,\n    n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"now SPLINT and quark coefficients","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"splint_params = QCDNUM.SPLINTParams();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"initialise QCDNUM","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"forward_model_init(qcdnum_params, splint_params)","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"run forward model","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"counts_pred_ep, counts_pred_em = forward_model(pdf_params, qcdnum_params,\n    splint_params, quark_coeffs);\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"take a poisson sample","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"nbins = size(counts_pred_ep)[1]\ncounts_obs_ep = zeros(UInt64, nbins)\ncounts_obs_em = zeros(UInt64, nbins)\n\nfor i in 1:nbins\n    counts_obs_ep[i] = rand(rng, Poisson(counts_pred_ep[i]))\n    counts_obs_em[i] = rand(rng, Poisson(counts_pred_em[i]))\nend","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"plot(1:nbins, counts_pred_ep, label=\"Expected counts (eP)\", color=\"blue\")\nplot!(1:nbins, counts_pred_em, label=\"Expected counts (eM)\", color=\"red\")\nscatter!(1:nbins, counts_obs_ep, label=\"Detected counts (eP)\", color=\"blue\")\nscatter!(1:nbins, counts_obs_em, label=\"Detected counts (eM)\", color=\"red\")\nplot!(xlabel=\"Bin number\")","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"store","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"sim_data = Dict{String,Any}()\nsim_data[\"nbins\"] = nbins;\nsim_data[\"counts_obs_ep\"] = counts_obs_ep;\nsim_data[\"counts_obs_em\"] = counts_obs_em;\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"write to file","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"pd_write_sim(\"output/simulation.h5\", pdf_params, sim_data)\nQCDNUM.save_params(\"output/params_val.h5\", qcdnum_params)\nQCDNUM.save_params(\"output/params_val.h5\", splint_params)","category":"page"},{"location":"bat_fit_valence/#Fit-the-simulated-data","page":"Fit with valence parametrisation","title":"Fit the simulated data","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Now we can try to fit this simulated data using Bat.jl. The first step is to define the prior and likelihood. For now, let's try relatively narrow priors centred on the true values.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"prior = NamedTupleDist(\n    θ_tmp=Dirichlet(weights),\n    λ_u=Truncated(Normal(pdf_params.λ_u, 1), 0, 1),\n    K_u=Truncated(Normal(pdf_params.K_u, 1), 2, 10),\n    λ_d=Truncated(Normal(pdf_params.λ_d, 1), 0, 1),\n    K_d=Truncated(Normal(pdf_params.K_d, 1), 2, 10),\n    λ_g1=Truncated(Normal(pdf_params.λ_g1, 1), -1, 0),\n    λ_g2=Truncated(Normal(pdf_params.λ_g2, 1), -1, 0),\n    K_g=Truncated(Normal(pdf_params.K_g, 1), 2, 10),\n    λ_q=Truncated(Normal(pdf_params.λ_q, 0.1), -1, 0),\n    K_q=Truncated(Normal(pdf_params.K_q, 0.5), 3, 7)\n);\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"The likelihood is similar to that used in the input PDF parametrisation example. We start by accessing the current parameter set of the sampler's iteration, then running the forward model to get the predicted counts and comparing to the observed counts using a simple Poisson likelihood.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"The @critical macro is used because forward_model() is currently not thread safe, so this protects it from being run in parallel.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"likelihood = let d = sim_data\n\n    counts_obs_ep = d[\"counts_obs_ep\"]\n    counts_obs_em = d[\"counts_obs_em\"]\n    nbins = d[\"nbins\"]\n\n    logfuncdensity(function (params)\n\n        θ = get_scaled_θ(params.λ_u, params.K_u, params.λ_d,\n            params.K_d, Vector(params.θ_tmp))\n\n        pdf_params = ValencePDFParams(λ_u=params.λ_u, K_u=params.K_u, λ_d=params.λ_d,\n            K_d=params.K_d, λ_g1=params.λ_g1, λ_g2=params.λ_g2,\n            K_g=params.K_g, λ_q=params.λ_q, K_q=params.K_q, θ=θ)\n\n        counts_pred_ep, counts_pred_em = @critical forward_model(pdf_params,\n            qcdnum_params, splint_params, quark_coeffs)\n\n        ll_value = 0.0\n        for i in 1:nbins\n            ll_value += logpdf(Poisson(counts_pred_ep[i]), counts_obs_ep[i])\n            ll_value += logpdf(Poisson(counts_pred_em[i]), counts_obs_em[i])\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We can now run the MCMC sampler. We will start by using the Metropolis-Hastings algorithm as implemented in BAT.jl. To get reasonable results, we need to run the sampler for a long time (several hours). To save time in this demo, we will work with a ready-made results file. To actually run the sampler, simply uncomment the code below.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"#posterior = PosteriorDensity(likelihood, prior);\n\n#samples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^5, nchains=2)).result;\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Alternatively, we could also try a nested sampling approach here for comparison. This is easily done thanks to the interface of BAT.jl, you will just need to add the NestedSamplers.jl package.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"#import NestedSamplers\n#samples = bat_sample(posterior, EllipsoidalNestedSampling()).result","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"If you run the sampler, be sure to save the results for further analysis","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"#import HDF5\n#bat_write(\"output/results.h5\", samples)","category":"page"},{"location":"bat_fit_valence/#Analysing-the-results","page":"Fit with valence parametrisation","title":"Analysing the results","text":"","category":"section"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"First, let's load our simulation inputs and results","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"pdf_params, sim_data = pd_read_sim(\"output/demo_simulation_valence.h5\");\nsamples = bat_read(\"output/demo_results_valence.h5\").result;\nnothing #hide","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We can use the same QCDNUM params as above","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"loaded_params = QCDNUM.load_params(\"output/params_val.h5\")\nqcdnum_params = loaded_params[\"evolution_params\"]\nsplint_params = loaded_params[\"splint_params\"]","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We can check some diagnostics using built in BAT.jl, such as the effective sample size shown below","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"bat_eff_sample_size(unshaped.(samples))[1]","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We see a value for each of our 15 total parameters. As the Metropolis-Hastings algorithm's default implementation isn't very efficient, we see that the effective sample size is only a small percentage of the input nsteps. We should try to improve this if possible, or use a much larger nsteps value.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"For demonstration purposes, we will continue to show how we can visualise the results in this case. For robust inference, we need to improve the sampling stage above.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"We can use BAT.jl's built in plotting recipes to show the marginals, for example, consider λ_u, and compare to the known truth.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"plot(\n    samples, :(λ_u),\n    nbins=50,\n    colors=[:skyblue4, :skyblue3, :skyblue1],\n    alpha=0.7,\n    marginalmode=false,\n    legend=:topleft\n)\nvline!([pdf_params.λ_u], color=\"black\", label=\"truth\", lw=3)","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"If we want to compare the momentum weights, we must transform from θ_tmp to θ, as shown below. Here, we transform using a helper function, convert the result to a matrix, and access the ith weight with the integer i.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"θ = [get_scaled_θ(λ_u, K_u, λ_d, K_d, Vector(θ_tmp)) for (λ_u, K_u, λ_d, K_d, θ_tmp)\n     in\n     zip(samples.v.λ_u, samples.v.K_u, samples.v.λ_d, samples.v.K_d, samples.v.θ_tmp)];\n\nθ = transpose(reduce(vcat, transpose.(θ)))\n\ni = 1\nhist = append!(Histogram(0:0.02:1), θ[i, :])\nplot(\n    normalize(hist, mode=:density),\n    st=:steps, label=\"Marginal posterior\"\n)\nvline!([pdf_params.θ[i]], color=\"black\", label=\"truth\", lw=3)","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Rather than making a large plot 15 different marginals, it can be more useful to visualise the posterior distribution in differently, such as the shape of the distributions we are trying to fit, or the model space. Helper functions exist for doing just this.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Using BAT recipe","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"function wrap_xtotx(p::NamedTuple, x::Real)\n    θ = get_scaled_θ(p.λ_u, p.K_u, p.λ_d, p.K_d, Vector(p.θ_tmp))\n    pdf_params = ValencePDFParams(λ_u=p.λ_u, K_u=p.K_u, λ_d=p.λ_d, K_d=p.K_d, λ_g1=p.λ_g1,\n        λ_g2=p.λ_g2, K_g=p.K_g, λ_q=p.λ_q, K_q=p.K_q, θ=θ)\n    return log(xtotx(x, pdf_params))\nend\n\nx_grid = range(1e-3, stop=1, length=50)\nplot(x_grid, wrap_xtotx, samples, colors=[:skyblue4, :skyblue3, :skyblue1],\n    legend=:topright)\nplot!(x_grid, [log(xtotx(x, pdf_params)) for x in x_grid], color=\"black\", lw=3,\n    label=\"Truth\", linestyle=:dash)\nplot!(ylabel=\"log(xtotx)\")","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Using PartonDensity.jl","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"plot_model_space(pdf_params, samples, nsamples=500)","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"Alternatively, we can also visualise the implications of the fit in the data space, as shown below.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"plot_data_space(pdf_params, sim_data, samples, qcdnum_params,\n    splint_params, quark_coeffs, nsamples=500)","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"The first results seem promising, but these are really just first checks and more work will have to be done to verify the method.","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"","category":"page"},{"location":"bat_fit_valence/","page":"Fit with valence parametrisation","title":"Fit with valence parametrisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/zeus_interface.jl\"","category":"page"},{"location":"zeus_interface/#ZEUS-interface","page":"ZEUS interface","title":"ZEUS interface","text":"","category":"section"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"Here is a short demonstration of how to access the ZEUS transfer matrix and bin interface.","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"using PartonDensity, CSV, DelimitedFiles","category":"page"},{"location":"zeus_interface/#Transfer-matrix","page":"ZEUS interface","title":"Transfer matrix","text":"","category":"section"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"eMPp = 1 # e+/e- switch 0/1","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"Read in an example integrated cross section","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"numbers_from_file = readdlm(\"data/HERAPDF20_NNLO_EIG_ePp.txt\")","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"List of integrated cross section values in 429 bins","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"integ_xsec = numbers_from_file[:,3]","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"Corresponding list of expected event numbers","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"prediction = get_pred_N(integ_xsec, eMPp);\n\ninteg_xsec[153]\n\nprediction[151]","category":"page"},{"location":"zeus_interface/#Bins-in-detector-space","page":"ZEUS interface","title":"Bins in detector space","text":"","category":"section"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"The transfer matrix projects into a list of 153 bins with irregular x and Q2 spacing. The bin edges are provided in data/zeus_bin_edges.jl but can also be quickly and easily accessed with the helper function get_bin_info as shown below.","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"get_bin_info(10)","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"","category":"page"},{"location":"zeus_interface/","page":"ZEUS interface","title":"ZEUS interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/bat_fit_dirichlet.jl\"","category":"page"},{"location":"bat_fit_dirichlet/#Fit-with-Dirichlet-parametrisation","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"In this example we show how to bring the PDF parametrisation and forward model together with BAT.jl to perform a fit of simulated data. This fit is a work in progress and just a starting point for verification of the method.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"using BAT, DensityInterface\nusing PartonDensity\nusing QCDNUM\nusing Plots, Random, Distributions, ValueShapes, ParallelProcessingTools\nusing StatsBase, LinearAlgebra\n\ngr(fmt=:png);\nrng = MersenneTwister(42)","category":"page"},{"location":"bat_fit_dirichlet/#Simulate-some-data","page":"Fit with Dirichlet parametrisation","title":"Simulate some data","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We can start off by simulating some fake data for us to fit. This way, we know exactly what initial conditions we have specified and can check the validity of our inference, assuming the generative model is the one that is producing our data.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"This is a good first check to work with.","category":"page"},{"location":"bat_fit_dirichlet/#Specify-the-input-PDFs","page":"Fit with Dirichlet parametrisation","title":"Specify the input PDFs","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"See the Input PDF parametrisation and priors example for more information on the definition of the input PDFs. Here, we use the Dirichlet parametrisation.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"weights = [30.0, 15.0, 12.0, 6.0, 3.6, 0.85, 0.85, 0.85, 0.85]\nθ = rand(rng, Dirichlet(weights))\npdf_params = DirichletPDFParams(K_u=4.0, K_d=4.0, λ_g1=1.5, λ_g2=-0.4, K_g=6.0,\n    λ_q=-0.25, K_q=5.0, θ=θ);\n\n@info \"Valence λ:\" pdf_params.λ_u pdf_params.λ_d\n\nplot_input_pdfs(pdf_params)","category":"page"},{"location":"bat_fit_dirichlet/#Go-from-PDFs-to-counts-in-ZEUS-detector-bins","page":"Fit with Dirichlet parametrisation","title":"Go from PDFs to counts in ZEUS detector bins","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Given the input PDFs, we can then evolve, calculate the cross sections, and fold through the ZEUS transfer matrix to get counts in bins. Here, we make use of some simple helper functions to do so. For more details, see the Forward model example.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"first specify QCDNUM inputs","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"qcdnum_grid = QCDNUM.GridParams(x_min=[1.0e-3, 1.0e-1, 5.0e-1], x_weights=[1, 2, 2], nx=100,\n    qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\nqcdnum_params = QCDNUM.EvolutionParams(order=2, α_S=0.118, q0=100.0, grid_params=qcdnum_grid,\n    n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"now SPLINT and quark coefficients","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"splint_params = QCDNUM.SPLINTParams();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"initialise QCDNUM","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"forward_model_init(qcdnum_params, splint_params)","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"run forward model","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"counts_pred_ep, counts_pred_em = forward_model(pdf_params, qcdnum_params,\n    splint_params, quark_coeffs);\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"take a poisson sample","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"nbins = size(counts_pred_ep)[1]\ncounts_obs_ep = zeros(UInt64, nbins)\ncounts_obs_em = zeros(UInt64, nbins)\n\nfor i in 1:nbins\n    counts_obs_ep[i] = rand(Poisson(counts_pred_ep[i]))\n    counts_obs_em[i] = rand(Poisson(counts_pred_em[i]))\nend","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"plot(1:nbins, counts_pred_ep, label=\"Expected counts (eP)\", color=\"blue\")\nplot!(1:nbins, counts_pred_em, label=\"Expected counts (eM)\", color=\"red\")\nscatter!(1:nbins, counts_obs_ep, label=\"Detected counts (eP)\", color=\"blue\")\nscatter!(1:nbins, counts_obs_em, label=\"Detected counts (eM)\", color=\"red\")\nplot!(xlabel=\"Bin number\")","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"store","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"sim_data = Dict{String,Any}()\nsim_data[\"nbins\"] = nbins;\nsim_data[\"counts_obs_ep\"] = counts_obs_ep;\nsim_data[\"counts_obs_em\"] = counts_obs_em;\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"write to file","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"pd_write_sim(\"output/simulation.h5\", pdf_params, sim_data)\nQCDNUM.save_params(\"output/params_dir.h5\", qcdnum_params)\nQCDNUM.save_params(\"output/params_dir.h5\", splint_params)","category":"page"},{"location":"bat_fit_dirichlet/#Fit-the-simulated-data","page":"Fit with Dirichlet parametrisation","title":"Fit the simulated data","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Now we can try to fit this simulated data using Bat.jl. The first step is to define the prior and likelihood. For now, let's try relatively narrow priors centred on the true values.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"prior = NamedTupleDist(\n    θ=Dirichlet(weights),\n    K_u=Uniform(3.0, 7.0),\n    K_d=Uniform(3.0, 7.0),\n    λ_g1=Uniform(1.0, 2.0),\n    λ_g2=Uniform(-0.5, -0.1),\n    K_g=Uniform(3.0, 7.0),\n    λ_q=Uniform(-0.5, -0.1),\n    K_q=Uniform(3.0, 7.0),\n);\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"The likelihood is similar to that used in the input PDF parametrisation example. We start by accessing the current parameter set of the sampler's iteration, then running the forward model to get the predicted counts and comparing to the observed counts using a simple Poisson likelihood.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"The @critical macro is used because forward_model() is currently not thread safe, so this protects it from being run in parallel.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"likelihood = let d = sim_data\n\n    counts_obs_ep = d[\"counts_obs_ep\"]\n    counts_obs_em = d[\"counts_obs_em\"]\n    nbins = d[\"nbins\"]\n\n    logfuncdensity(function (params)\n\n        pdf_params = DirichletPDFParams(K_u=params.K_u, K_d=params.K_d, λ_g1=params.λ_g1, λ_g2=params.λ_g2,\n            K_g=params.K_g, λ_q=params.λ_q, K_q=params.K_q, θ=Vector(params.θ))\n\n        counts_pred_ep, counts_pred_em = @critical forward_model(pdf_params,\n            qcdnum_params, splint_params, quark_coeffs)\n\n        ll_value = 0.0\n        for i in 1:nbins\n            ll_value += logpdf(Poisson(counts_pred_ep[i]), counts_obs_ep[i])\n            ll_value += logpdf(Poisson(counts_pred_em[i]), counts_obs_em[i])\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We can now run the MCMC sampler. We will start by using the Metropolis-Hastings algorithm as implemented in BAT.jl. To get reasonable results, we need to run the sampler for a long time (several hours). To save time in this demo, we will work with a ready-made results file. To actually run the sampler, simply uncomment the code below.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"#posterior = PosteriorDensity(likelihood, prior);\n#samples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=2)).result;\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Alternatively, we could also try a nested sampling approach here for comparison. This is easily done thanks to the interface of BAT.jl, you will just need to add the NestedSamplers.jl package.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"#import NestedSamplers\n#samples = bat_sample(posterior, EllipsoidalNestedSampling()).result","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"If you run the sampler, be sure to save the results for further analysis","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"#import HDF5\n#bat_write(\"output/results.h5\", samples)","category":"page"},{"location":"bat_fit_dirichlet/#Analysing-the-results","page":"Fit with Dirichlet parametrisation","title":"Analysing the results","text":"","category":"section"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"First, let's load our simulation inputs and results","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"pdf_params, sim_data = pd_read_sim(\"output/demo_simulation_dirichlet.h5\");\nsamples = bat_read(\"output/demo_results_dirichlet.h5\").result;\nnothing #hide","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We can use the same QCDNUM params as above","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"loaded_params = QCDNUM.load_params(\"output/params_dir.h5\")\nqcdnum_params = loaded_params[\"evolution_params\"]\nsplint_params = loaded_params[\"splint_params\"]","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We can check some diagnostics using built in BAT.jl, such as the effective sample size shown below","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"bat_eff_sample_size(unshaped.(samples))[1]","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We see a value for each of our 15 total parameters. As the Metropolis-Hastings algorithm's default implementation isn't very efficient, we see that the effective sample size is only a small percentage of the input nsteps. We should try to improve this if possible, or use a much larger nsteps value.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"For demonstration purposes, we will continue to show how we can visualise the results in this case. For robust inference, we need to improve the sampling stage above.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"We can use BAT.jl's built in plotting recipes to show the marginals, for example, consider λ_u, and compare to the known truth.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"plot(\n    samples, :(K_u),\n    nbins=50,\n    colors=[:skyblue4, :skyblue3, :skyblue1],\n    alpha=0.7,\n    marginalmode=false,\n    legend=:topleft\n)\nvline!([pdf_params.K_u], color=\"black\", label=\"truth\", lw=3)","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"If we want to compare the momentum weights, we no longer need to transform (compared to the valence parametrisation case) and can simply use the BAT.jl recipes as before.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"plot(\n    samples, (:(θ[1]), :(θ[2])),\n    nbins=50,\n    colors=[:skyblue4, :skyblue3, :skyblue1],\n    alpha=0.7,\n    marginalmode=false,\n    legend=:topright\n)\n\nvline!([pdf_params.θ[1]], color=\"black\", label=\"true θ[1]\", lw=3)\nhline!([pdf_params.θ[2]], color=\"black\", label=\"true θ[2]\", lw=3)","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Rather than making a large plot 15 different marginals, it can be more useful to visualise the posterior distribution in differently, such as the shape of the distributions we are trying to fit, or the model space. Helper functions exist for doing just this.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Using BAT recipe","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"function wrap_xtotx(p::NamedTuple, x::Real)\n    pdf_params = DirichletPDFParams(K_u=p.K_u, K_d=p.K_d, λ_g1=p.λ_g1,\n        λ_g2=p.λ_g2, K_g=p.K_g, λ_q=p.λ_q, K_q=p.K_q, θ=Vector(p.θ))\n    return log(xtotx(x, pdf_params))\nend\n\nx_grid = range(1e-3, stop=1, length=50)\nplot(x_grid, wrap_xtotx, samples, colors=[:skyblue4, :skyblue3, :skyblue1],\n    legend=:topright)\nplot!(x_grid, [log(xtotx(x, pdf_params)) for x in x_grid], color=\"black\", lw=3,\n    label=\"Truth\", linestyle=:dash)\nplot!(ylabel=\"log(xtotx)\")","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Using PartonDensity.jl","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"plot_model_space(pdf_params, samples, nsamples=500)","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"Alternatively, we can also visualise the implications of the fit in the data space, as shown below.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"plot_data_space(pdf_params, sim_data, samples, qcdnum_params,\n    splint_params, quark_coeffs, nsamples=500)","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"The first results seem promising, but these are really just first checks and more work will have to be done to verify the method.","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"","category":"page"},{"location":"bat_fit_dirichlet/","page":"Fit with Dirichlet parametrisation","title":"Fit with Dirichlet parametrisation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/prior_bat_implementation.jl\"","category":"page"},{"location":"prior_bat_implementation/#Prior-model-implementation-in-BAT.jl","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"In this notebook, the implementation of the prior model is demonstrated, starting with a simple two-component model and scaling up to the full 9 component model.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"using Distributions, StatsBase, LinearAlgebra\nusing Plots, SpecialFunctions, Printf, Random, ValueShapes\nusing BAT, DensityInterface\nconst sf = SpecialFunctions;\n\ngr(fmt=:png);\nrng = MersenneTwister(42)","category":"page"},{"location":"prior_bat_implementation/#Simple-two-component-model:-gluons","page":"Prior model implementation in BAT.jl","title":"Simple two-component model: gluons","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"First we start with a simpler two-component model, and show all the steps explicity for clarity.","category":"page"},{"location":"prior_bat_implementation/#Forward-model","page":"Prior model implementation in BAT.jl","title":"Forward model","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The gluon distributions are parametrised by","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x g(x) = A_g1 x^lambda_g1(1-x)^K_g + A_g2 x^lambda_g2(1-x)^5","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We also want to impose","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"int_0^1 x g(x) dx = A_g1 B(lambda_g1+1 K_g+1) + A_g2 B(lambda_g2+1 1+5) = 1","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"with B(.,.) the Beta function.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Start by defining some useful functions:","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"function xg1x(x, λ_g1, K_g, θ_1)\n    A_g1 = θ_1 / sf.beta(λ_g1 + 1, K_g + 1)\n    return A_g1 * x^λ_g1 * (1 - x)^K_g\nend\n\nfunction xg2x(x, λ_g2, K_q, θ_2)\n    A_g2 = θ_2 / sf.beta(λ_g2 + 1, K_q + 1)\n    return A_g2 * x^λ_g2 * (1 - x)^K_q\nend\n\nfunction xgx(x, λ_g1, λ_g2, K_g, K_q, θ)\n    xg1 = xg1x(x, λ_g1, K_g, θ[1])\n    xg2 = xg2x(x, λ_g2, K_q, θ[2])\n    return xg1 + xg2\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Choose true values for the high-level parameters and show what the resulting model looks like.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"θ = [0.5, 0.5]\nλ_g1 = 0.5 # rand(rng, Uniform(0, 1))\nλ_g2 = -0.7 # rand(rng, Uniform(-1, 0))\nK_g = 3 # rand(rng, Uniform(2, 10))\nK_q = 5\ntruths = (θ=θ, λ_g1=λ_g1, λ_g2=λ_g2, K_g=K_g, K_q=K_q);\n\nA_g1 = θ[1] / sf.beta(λ_g1 + 1, K_g + 1)\nA_g2 = θ[2] / sf.beta(λ_g2 + 1, K_q + 1);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Check integral = 1","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"total = A_g1 * sf.beta(λ_g1 + 1, K_g + 1) + A_g2 * sf.beta(λ_g2 + 1, K_q + 1)\nprint(\"Integral = \", total)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot true model","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x_grid = range(0, stop=1, length=50)\n\nxg1 = A_g1 * x_grid .^ λ_g1 .* (1 .- x_grid) .^ K_g\nxg2 = A_g2 * x_grid .^ λ_g2 .* (1 .- x_grid) .^ K_q\n\nplot(x_grid, [xg1x(x, λ_g1, K_g, θ[1]) for x in x_grid],\n    alpha=0.7, label=\"x g1(x)\", lw=3, color=\"green\")\nplot!(x_grid, [xg2x(x, λ_g2, K_q, θ[2]) for x in x_grid],\n    alpha=0.7, label=\"x g2(x)\", lw=3, color=\"blue\")\nplot!(x_grid, [xgx(x, λ_g1, λ_g2, K_g, K_q, θ) for x in x_grid],\n    alpha=0.7, label=\"x g1(x) + x g2(x)\", lw=3, color=\"red\")\nplot!(xlabel=\"x\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Now, for the purposes of testing the prior implementation, sample some data from this distribution assuming that the data are produced by integrating over the function in different bins, and multiplying by some factor. Then, plot the model and data to compare.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"bins = 0.0:0.05:1.0\nbin_widths = bins[2:end] - bins[1:end-1]\nbin_centers = (bins[1:end-1] + bins[2:end]) / 2\n\nN = 1000\nnbins = size(bin_centers)[1]\n\nexpected_counts = zeros(nbins)\nobserved_counts = zeros(Integer, nbins)\nfor i in 1:nbins\n    xg = xgx(bin_centers[i], λ_g1, λ_g2, K_g, K_q, θ) * N\n    expected_counts[i] = bin_widths[i] * xg\n    observed_counts[i] = rand(rng, Poisson(expected_counts[i]))\nend\n\nplot(bin_centers, [xgx(x, λ_g1, λ_g2, K_g, K_q, θ) for x in bin_centers] .* bin_widths * N,\n    alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Store the data in a simple dict to pass to the likelihood later.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"data = Dict()\ndata[\"N\"] = N\ndata[\"bin_centers\"] = bin_centers;\ndata[\"observed_counts\"] = observed_counts;\ndata[\"bin_widths\"] = bin_widths;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Fit","page":"Prior model implementation in BAT.jl","title":"Fit","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"To fit this example data, we choose a prior over our hyperparameters θ, λ_g1, λ_g2, K_g and K_q.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We decide to choose a sensible Dirichlet prior, and have a look at some samples to help understand what this means.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"dirichlet = Dirichlet([1, 1])\ntest = rand(rng, dirichlet, 1000)\nplot(append!(Histogram(0:0.1:1), test[1, :]))\nplot!(append!(Histogram(0:0.1:1), test[2, :]))","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"So, we see that this means all weights are equally likely for both components.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Now we can define the prior:","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"mathrmPrior - P(theta) P(lambda_g1) P(lambda_g2) P(K_g)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"prior = NamedTupleDist(\n    θ=Dirichlet([1, 1]),\n    λ_g1=Uniform(0, 1), #Truncated(Normal(0.7, 0.1), 0, 1)\n    λ_g2=Uniform(-1, 0), #Truncated(Normal(-0.7, 0.1), -1, 0),\n    K_g=Uniform(2, 10), # Truncated(Normal(1, 2), 2, 10),\n    K_q=Uniform(4, 6),\n);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Define a simple poisson likelihood that describes the test data that we generated above.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"likelihood = let d = data, f = xgx\n\n    observed_counts = d[\"observed_counts\"]\n    bin_centers = d[\"bin_centers\"]\n    bin_widths = d[\"bin_widths\"]\n    N = data[\"N\"]\n\n    logfuncdensity(function (params)\n        function bin_log_likelihood(i)\n            xg = f(\n                bin_centers[i], params.λ_g1, params.λ_g2, params.K_g, params.K_q, params.θ\n            )\n            expected_counts = bin_widths[i] * xg * N\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The prior and likelihood can be passed to BAT.jl via the PosteriorDensity. We can then sample this density using bat_sample().","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"posterior = PosteriorDensity(likelihood, prior);\nsamples = bat_sample(\n    posterior,\n    MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=4)\n).result;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The SampledDensity gives a quick overview of the results.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"SampledDensity(posterior, samples)","category":"page"},{"location":"prior_bat_implementation/#Visualise-results","page":"Prior model implementation in BAT.jl","title":"Visualise results","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can (roughly) check how well the fit reconstructs the truth with a simple comparison.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x_grid = range(0, stop=1, length=50)\nsub_samples = bat_sample(samples, OrderedResampling(nsamples=200)).result\n\nplot()\nfor i in eachindex(sub_samples)\n    s = sub_samples[i].v\n    xg = [xgx(x, s.λ_g1, s.λ_g2, s.K_g, s.K_q, s.θ) for x in bin_centers]\n    plot!(bin_centers, xg .* bin_widths * N, alpha=0.1, lw=3,\n        color=\"darkorange\", label=\"\",)\nend\n\nxg = [xgx(x, λ_g1, λ_g2, K_g, K_q, θ) for x in bin_centers]\nplot!(bin_centers, xg .* bin_widths * N, alpha=0.7,\n    label=\"Expected\", lw=3, color=\"red\")\n\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")\n\nplot!(xlabel=\"x\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"In the above plot, the red line represents the truth, and the set of fainter lines represent samples from the posterior.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can also look at marginal distributions for different parameters...","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot(\n    samples, :(λ_g1),\n    mean=true, std=true,\n    nbins=50,\n)","category":"page"},{"location":"prior_bat_implementation/#Full-model-with-all-components","page":"Prior model implementation in BAT.jl","title":"Full model with all components","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can now extend this approach to the full 9 components, there is not so much documentation here, as it follows the above case.","category":"page"},{"location":"prior_bat_implementation/#Forward-model-2","page":"Prior model implementation in BAT.jl","title":"Forward model","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Here the parametrisation of each component in decreasing order of importance. We also use the helper functions provided by PartonDensity to keep things tidy.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"using PartonDensity","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"weights = [1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1]\nλ_u = 0.7;\nK_u = 4.0;\nλ_d = 0.5;\nK_d = 6.0;\nθ = get_θ_val(rng, λ_u, K_u, λ_d, K_d, weights)\npdf_params = ValencePDFParams(λ_u=λ_u, K_u=K_u, λ_d=λ_d, K_d=K_d,\n    λ_g1=0.7, λ_g2=-0.4, K_g=6.0, λ_q=-0.5, K_q=5.0,\n    θ=θ)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Sanity check","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"int_xtotx(pdf_params)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot true model","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot_input_pdfs(pdf_params)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Generate example data","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"bins = 0.0:0.05:1.0\nbin_widths = bins[2:end] - bins[1:end-1]\nbin_centers = (bins[1:end-1] + bins[2:end]) / 2\n\nN = 1000\nnbins = size(bin_centers)[1]\n\nexpected_counts = zeros(nbins)\nobserved_counts = zeros(Integer, nbins)\nfor i in 1:nbins\n    xt = xtotx(bin_centers[i], pdf_params) * N\n    expected_counts[i] = bin_widths[i] * xt\n    observed_counts[i] = rand(rng, Poisson(expected_counts[i]))\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot data and expectation","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot(bin_centers, [xtotx(x, pdf_params) for x in bin_centers] .* bin_widths * N,\n    alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Store the data","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"data = Dict()\ndata[\"N\"] = N\ndata[\"bin_centers\"] = bin_centers;\ndata[\"observed_counts\"] = observed_counts;\ndata[\"bin_widths\"] = bin_widths;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Fit-2","page":"Prior model implementation in BAT.jl","title":"Fit","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Prior","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"prior = NamedTupleDist(\n    θ=Dirichlet(weights),\n    λ_u=Truncated(Normal(pdf_params.λ_u, 0.5), 0, 1), #  Uniform(0, 1),\n    K_u=Truncated(Normal(pdf_params.K_u, 1), 2, 10),\n    λ_d=Truncated(Normal(pdf_params.λ_d, 0.5), 0, 1), # Uniform(0, 1),\n    K_d=Truncated(Normal(pdf_params.K_d, 1), 2, 10),\n    λ_g1=Truncated(Normal(pdf_params.λ_g1, 1), 0, 1),\n    λ_g2=Truncated(Normal(pdf_params.λ_g2, 1), -1, 0),\n    K_g=Truncated(Normal(pdf_params.K_g, 1), 2, 10),\n    λ_q=Truncated(Normal(pdf_params.λ_q, 0.1), -1, 0),\n    K_q=Truncated(Normal(pdf_params.K_q, 0.5), 3, 7)\n);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Likelihood","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"likelihood = let d = data, f = PartonDensity.xtotx_valence\n\n    observed_counts = d[\"observed_counts\"]\n    bin_centers = d[\"bin_centers\"]\n    bin_widths = d[\"bin_widths\"]\n    N = data[\"N\"]\n\n    logfuncdensity(function (params)\n        function bin_log_likelihood(i)\n            xt = f(bin_centers[i], params.λ_u, params.K_u, params.λ_d, params.K_d,\n                params.λ_g1, params.λ_g2, params.K_g, params.λ_q, params.K_q, Vector(params.θ))\n            expected_counts = bin_widths[i] * xt * N\n            if expected_counts < 0\n                expected_counts = 1e-3\n            end\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Run fit","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"posterior = PosteriorDensity(likelihood, prior);\nsamples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=2)).result;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Visualise-results-2","page":"Prior model implementation in BAT.jl","title":"Visualise results","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x_grid = range(0, stop=1, length=50)\nsub_samples = bat_sample(samples, OrderedResampling(nsamples=200)).result\n\nplot()\nfor i in eachindex(sub_samples)\n    s = sub_samples[i].v\n    xt = [PartonDensity.xtotx_valence(x, s.λ_u, s.K_u, s.λ_d, s.K_d,\n        s.λ_g1, s.λ_g2, s.K_g, s.λ_q, s.K_q, Vector(s.θ)) for x in bin_centers]\n    plot!(bin_centers, xt .* bin_widths * N, alpha=0.1, lw=3,\n        color=\"darkorange\", label=\"\")\nend\nxt = [xtotx(x, pdf_params) for x in bin_centers]\nplot!(bin_centers, xt .* bin_widths * N, alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\n\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")\nplot!(xlabel=\"x\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"These first results are promising. We can also try changing the input parameters and priors to explore the performance of the fit.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/pdf_parametrisation.jl\"","category":"page"},{"location":"pdf_parametrisation/#Input-PDF-parametrisation-and-priors","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"An important part of PDF fitting is defining a useful parametrisation for the PDF shapes, as well as meaningful prior distributions that encode our knowledge of the problem.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"In this notebook, and in the PartonDensity package, we explore two different approaches:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Full Dirichlet\nValence shape + Dirichlet","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We are still investigating which approach will be most effective, and so both options are currently implemented, as detailed below.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using Distributions, Plots, SpecialFunctions, Printf\nconst sf = SpecialFunctions;\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/#\"Full-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Full Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A clean way to ensure the momentum sum rule would be to sample different contributions of the momentrum density integral from a Dirichlet distribution, then use these weights to set the parameters on the individual Beta distributions.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"9 components of decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"dirichlet = Dirichlet([3.0, 2.0, 1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1])\ndata = rand(dirichlet, 1000);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Have a look","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"plot()\nfor i in 1:9\n    histogram!(data[i, :], bins=range(0, stop=1, length=20), alpha=0.7)\nend\nplot!(xlabel=\"I_i = A_i B_i\")","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This would be great as the sum rule is automatically conserved","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"sum(data, dims=1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"But, it could be non-trivial to choose the Dirichlet weights for a sensible prior, and connect to the physics of the problem.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I = rand(dirichlet)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"As we are more interested in K_u and K_d than λ_u and λ_d for our high-x data, we can set the λs according to the Ks.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"K_u = rand(Uniform(2, 10))","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral of number density must = 2, and integral of momentum density must = I[1]. This implies the following:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = (I[1] * (K_u + 1)) / (2 - I[1])","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Let's check this","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A_u = 2 / sf.beta(λ_u, K_u + 1)\n\nI[1] ≈ A_u * sf.beta(λ_u + 1, K_u + 1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"While this approach might be nice, it could be hard to set priors on the shape of the valence distributions, as the λ_u and λ_d are now derived parameters, dependent on the specified Dirichlet weights and K_u/K_d values. However, sensible prior choices could be made using e.g. prior predictive checks.","category":"page"},{"location":"pdf_parametrisation/#\"Valence-shape-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Valence shape + Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"An alternative approach is to specify constraints on the valence params through the shape of their Beta distributions, then using a Dirichlet to specify the weights of the gluon and sea components. The problem here is it isn't clear how to specify that the d contribution must be less than the u contribution, but it is possible to do this indirectly through priors on the shape parameters. This would however also require some further investigation.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = range(0, stop=1, length=50)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"High-level priors Looks like we maybe want to change lambda and K priors to boost these components","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = 0.7 #rand(Uniform(0, 1))\nK_u = 4 #rand(Uniform(2, 10))\nλ_d = 0.5 #rand(Uniform(0, 1))\nK_d = 6 #rand(Uniform(2, 10))\n\nu_V = Beta(λ_u, K_u + 1)\nA_u = 2 / sf.beta(λ_u, K_u + 1)\n\nd_V = Beta(λ_d, K_d + 1)\nA_d = 1 / sf.beta(λ_d, K_d + 1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_u = A_u * sf.beta(λ_u + 1, K_u + 1)\nI_d = A_d * sf.beta(λ_d + 1, K_d + 1)\n\nplot(x, x .* A_u .* x .^ λ_u .* (1 .- x) .^ K_u * 2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x .* A_d .* x .^ λ_d .* (1 .- x) .^ K_d, alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:topright)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"@printf(\"I_u = %.2f\\n\", I_u)\n@printf(\"I_d = %.2f\\n\", I_d)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"The remaining 7 integrals can be dirichlet-sampled with decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"remaining = 1 - (I_u + I_d)\ndirichlet = Dirichlet([3.0, 2.0, 1, 0.5, 0.3, 0.2, 0.1])\nI = rand(dirichlet) * remaining;\nsum(I) ≈ remaining","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Gluon contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_g1 = rand(Uniform(-1, 0))\nλ_g2 = rand(Uniform(0, 1))\nK_g = rand(Uniform(2, 10))\nK_q = rand(Uniform(3, 7))\nA_g2 = I[1] / sf.beta(λ_g2 + 1, K_g + 1)\nA_g1 = I[2] / sf.beta(λ_g1 + 1, K_q + 1);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Sea quark contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_q = rand(Uniform(-1, 0))\nA_ubar = I[3] / (2 * sf.beta(λ_q + 1, K_q + 1))\nA_dbar = I[4] / (2 * sf.beta(λ_q + 1, K_q + 1))\nA_s = I[5] / (2 * sf.beta(λ_q + 1, K_q + 1))\nA_c = I[6] / (2 * sf.beta(λ_q + 1, K_q + 1))\nA_b = I[7] / (2 * sf.beta(λ_q + 1, K_q + 1));\n\ntotal = A_u * sf.beta(λ_u + 1, K_u + 1) + A_d * sf.beta(λ_d + 1, K_d + 1)\ntotal += A_g1 * sf.beta(λ_g1 + 1, K_q + 1) + A_g2 * sf.beta(λ_g2 + 1, K_g + 1)\ntotal += 2 * (A_ubar + A_dbar + A_s + A_c + A_b) * sf.beta(λ_q + 1, K_q + 1)\ntotal ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = 10 .^ range(-2, stop=0, length=500)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"How does it look?","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"xg2 = A_g2 * x .^ λ_g2 .* (1 .- x) .^ K_g\nxg1 = A_g1 * x .^ λ_g1 .* (1 .- x) .^ K_q\nplot(x, x .* A_u .* x .^ λ_u .* (1 .- x) .^ K_u * 2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x .* A_d .* x .^ λ_d .* (1 .- x) .^ K_d, alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(x, xg1 + xg2, alpha=0.7, label=\"x g(x)\", lw=3)\nplot!(x, A_ubar * x .^ λ_q .* (1.0 .- x) .^ K_q, alpha=0.7, label=\"x ubar(x)\", lw=3)\nplot!(x, A_dbar * x .^ λ_q .* (1.0 .- x) .^ K_q, alpha=0.7, label=\"x dbar(x)\", lw=3)\nplot!(x, A_s * x .^ λ_q .* (1.0 .- x) .^ K_q, alpha=0.7, label=\"x s(x)\", lw=3)\nplot!(x, A_c * x .^ λ_q .* (1.0 .- x) .^ K_q, alpha=0.7, label=\"x c(x)\", lw=3)\nplot!(x, A_b * x .^ λ_q .* (1.0 .- x) .^ K_q, alpha=0.7, label=\"x b(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:bottomleft, xscale=:log, ylims=(1e-8, 10), yscale=:log)","category":"page"},{"location":"pdf_parametrisation/#Prior-predictive-checks","page":"Input PDF parametrisation and priors","title":"Prior predictive checks","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We can start to visualise the type of PDFs that are allowed by the combination of the choice of parametrisation and prior distributions with some simple prior predictive checks, as done below for the valence style parametrisation...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"N = 100\nalpha = 0.03\ntotal = Array{Float64,1}(undef, N)\nfirst = true\nleg = 0\n\nplot()\nfor i in 1:N\n\n    λ_u_i = rand(Uniform(0, 1))\n    K_u_i = rand(Uniform(2, 10))\n    λ_d_i = rand(Uniform(0, 1))\n    K_d_i = rand(Uniform(2, 10))\n    A_u_i = 2 / sf.beta(λ_u_i, K_u_i + 1)\n    A_d_i = 1 / sf.beta(λ_d_i, K_d_i + 1)\n    I_u_i = A_u * sf.beta(λ_u_i + 1, K_u_i + 1)\n    I_d_i = A_d * sf.beta(λ_d_i + 1, K_d_i + 1)\n    u_V_i = Beta(λ_u_i, K_u_i + 1)\n    d_V_i = Beta(λ_d_i, K_d_i + 1)\n\n    remaining_i = 1 - (I_u_i + I_d_i)\n    dirichlet_i = Dirichlet([3.0, 2.0, 1, 0.5, 0.3, 0.2, 0.1])\n    I_i = rand(dirichlet_i) * remaining_i\n\n    λ_g1_i = rand(Uniform(-1, 0))\n    λ_g2_i = rand(Uniform(0, 1))\n    K_g_i = rand(Uniform(2, 10))\n    A_g2_i = I_i[1] / sf.beta(λ_g2_i + 1, K_g_i + 1)\n    A_g1_i = I_i[2] / sf.beta(λ_g1_i + 1, 5 + 1)\n\n    λ_q_i = rand(Uniform(-1, 0))\n    K_q_i = rand(Uniform(3, 7))\n    A_ubar_i = I_i[3] / (2 * sf.beta(λ_q_i + 1, K_q_i + 1))\n    A_dbar_i = I_i[4] / (2 * sf.beta(λ_q_i + 1, K_q_i + 1))\n    A_s_i = I_i[5] / (2 * sf.beta(λ_q_i + 1, K_q_i + 1))\n    A_c_i = I_i[6] / (2 * sf.beta(λ_q_i + 1, K_q_i + 1))\n    A_b_i = I_i[7] / (2 * sf.beta(λ_q_i + 1, K_q_i + 1))\n\n    total[i] = A_u_i * sf.beta(λ_u_i + 1, K_u_i + 1) + A_d_i * sf.beta(λ_d_i + 1, K_d_i + 1)\n    total[i] += A_g1_i * sf.beta(λ_g1_i + 1, K_q_i + 1) + A_g2_i * sf.beta(λ_g2_i + 1, K_g_i + 1)\n    total[i] += 2 * (A_ubar_i + A_dbar_i + A_s_i + A_c_i + A_b_i) * sf.beta(λ_q_i + 1, K_q_i + 1)\n\n    xg2_i = A_g2_i * x .^ λ_g2_i .* (1 .- x) .^ K_g_i\n    xg1_i = A_g1_i * x .^ λ_g1_i .* (1 .- x) .^ K_q_i\n    plot!(x, [x .* A_u_i .* x .^ λ_u_i .* (1 .- x) .^ K_u_i * 2], alpha=alpha, color=\"blue\", lw=3)\n    plot!(x, x .* A_d_i .* x .^ λ_d_i .* (1 .- x) .^ K_d_i, alpha=alpha, color=\"orange\", lw=3)\n    plot!(x, xg1_i + xg2_i, alpha=alpha, color=\"green\", lw=3)\n    plot!(x, A_ubar_i * x .^ λ_q_i .* (1 .- x) .^ K_q_i, alpha=alpha, color=\"red\", lw=3)\n    plot!(x, A_dbar_i * x .^ λ_q_i .* (1 .- x) .^ K_q_i, alpha=alpha, color=\"purple\", lw=3)\n    plot!(x, A_s_i * x .^ λ_q_i .* (1 .- x) .^ K_q_i, alpha=alpha, color=\"brown\", lw=3)\n    plot!(x, A_c_i * x .^ λ_q_i .* (1 .- x) .^ K_q_i, alpha=alpha, color=\"pink\", lw=3)\n    plot!(x, A_b_i * x .^ λ_q_i .* (1 .- x) .^ K_q_i, alpha=alpha, color=\"grey\", lw=3)\nend\n\nplot!(xlabel=\"x\", ylabel=\"x f(x)\", xscale=:log, legend=false,\n    ylims=(1e-8, 10), yscale=:log)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Looks like naive priors need some work...","category":"page"},{"location":"pdf_parametrisation/#PDF-Parametrisation-interface","page":"Input PDF parametrisation and priors","title":"PDF Parametrisation interface","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"PartonDensity provides a handy interface to both the parametrisations through the DirichletPDFParams and ValencePDFParams options.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using PartonDensity","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Let's try the Dirichlet specification...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"weights_dir = [3.0, 1.0, 5.0, 5.0, 1.0, 1.0, 1.0, 0.5, 0.5]\nθ_dir = rand(Dirichlet(weights_dir))\n\npdf_params = DirichletPDFParams(K_u=4.0, K_d=6.0, λ_g1=0.7, λ_g2=-0.4,\n    K_g=6.0, λ_q=-0.5, K_q=5.0, θ=θ_dir);\n\nplot_input_pdfs(pdf_params)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"int_xtotx(pdf_params) ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"And now the valence specification...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"weights_val = [5.0, 5.0, 1.0, 1.0, 1.0, 0.5, 0.5]\nλ_u = 0.7\nK_u = 4.0\nλ_d = 0.5\nK_d = 6.0\nθ_val = get_θ_val(λ_u, K_u, λ_d, K_d, weights_val)\npdf_params = ValencePDFParams(λ_u=λ_u, K_u=K_u, λ_d=λ_d, K_d=K_d, λ_g1=0.7, λ_g2=-0.4,\n    K_g=6.0, λ_q=-0.5, K_q=5.0, θ=θ_val);\n\nplot_input_pdfs(pdf_params)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"int_xtotx(pdf_params) ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/forward_model.jl\"","category":"page"},{"location":"forward_model/#Forward-model","page":"Forward model","title":"Forward model","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Here, we go through an example of simulating the full forward model, from the prior definition to the expected number of events in different bins of the detector response.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"using QCDNUM, PartonDensity\nusing Plots, Printf, NaNMath, Parameters, Random, Distributions","category":"page"},{"location":"forward_model/#Define-input-PDFs","page":"Forward model","title":"Define input PDFs","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"We can use DirichletPDFParams or ValencePDFParams, as long as we do so according to the PDF parametrisation and priors docs.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"random_seed = 42\n\nweights = [3.0, 1.0, 5.0, 5.0, 1.0, 1.0, 1.0, 0.5, 0.5]\nθ = rand(MersenneTwister(random_seed), Dirichlet(weights))\npdf_params = DirichletPDFParams(K_u=4.0, K_d=6.0, λ_g1=0.7, λ_g2=-0.4,\n    K_g=6.0, λ_q=-0.5, K_q=5.0, θ=θ);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Plot the input PDFs","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot_input_pdfs(pdf_params)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Sanity check that sum = 1","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"int_xtotx(pdf_params) ≈ 1","category":"page"},{"location":"forward_model/#Define-QCDNUM-grids,-weights-and-settings","page":"Forward model","title":"Define QCDNUM grids, weights and settings","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"grid = QCDNUM.GridParams(x_min=[1.0e-3], x_weights=[1], nx=100,\n    qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\n\nqcdnum_params = QCDNUM.EvolutionParams(order=2, α_S=0.118, q0=100.0, grid_params=grid,\n    n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Initialise","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.init()","category":"page"},{"location":"forward_model/#Evolve-the-PDFs-using-QCDNUM","page":"Forward model","title":"Evolve the PDFs using QCDNUM","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define input PDF function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"See QCDNUM docs under evolfg","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"There are functions available to generate the necessary input PDF function in the correct format for QCDNUM.jl (see get_input_pdf_func()), along with the mapping between this input function and quark species (see input_pdf_map).","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Get function and PDF input map to fully describe the QCDNUM.InputPDF","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"my_func = get_input_pdf_func(pdf_params)\ninput_pdf = QCDNUM.InputPDF(func=my_func, map=input_pdf_map)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Evolve the PDF over the specified grid","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"ϵ = QCDNUM.evolve(input_pdf, qcdnum_params)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"For splines","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"nw = QCDNUM.zmfillw()\nsplint_params = QCDNUM.SPLINTParams();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define initial spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_spinit(splint_params.nuser)\n\nia = QCDNUM.isp_s2make(splint_params.nsteps_x, splint_params.nsteps_q);\nxnd = QCDNUM.ssp_unodes(ia, splint_params.nnodes_x, 0);\nqnd = QCDNUM.ssp_vnodes(ia, splint_params.nnodes_q, 0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Check nodes and erase","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_nprint(ia);\nQCDNUM.ssp_erase(ia);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Set nodes and fill spline with structure function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iaFLup = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLup, qcdnum_params.output_pdf_loc, quark_coeffs.proup, 1, 0.0);\n\niaF2up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2up, qcdnum_params.output_pdf_loc, quark_coeffs.proup, 2, 0.0);\n\niaF3up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3up, qcdnum_params.output_pdf_loc, quark_coeffs.valup, 3, 0.0);\n\niaFLdn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLdn, qcdnum_params.output_pdf_loc, quark_coeffs.prodn, 1, 0.0);\n\niaF2dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2dn, qcdnum_params.output_pdf_loc, quark_coeffs.prodn, 2, 0.0);\n\niaF3dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3dn, qcdnum_params.output_pdf_loc, quark_coeffs.valdn, 3, 0.0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"store spline addresses","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_uwrite(splint_params.spline_addresses.F2up, Float64(iaF2up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F2dn, Float64(iaF2dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3up, Float64(iaF3up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3dn, Float64(iaF3dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLup, Float64(iaFLup));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLdn, Float64(iaFLdn));\n\nmy_funcp = get_input_xsec_func(1) # charge = 1\ninput_xsecp = @cfunction(my_funcp, Float64, (Ref{Int32}, Ref{Int32}, Ref{UInt8}))\n\nmy_funcm = get_input_xsec_func(-1) # charge = -1\ninput_xsecm = @cfunction(my_funcm, Float64, (Ref{Int32}, Ref{Int32}, Ref{UInt8}))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"g = qcdnum_params.grid_params\nxsec_on_grid = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        xsec_on_grid[ix, iq] = _fun_xsec_i(1, ix, iq) # charge = 1\n    end\nend\n\nqcdnum_x_grid = QCDNUM.gxcopy(g.nx)\nqcdnum_qq_grid = QCDNUM.gqcopy(g.nq)\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(xsec_on_grid[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n    xaxis=:log, yaxis=:log)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 4]),\n    label=\"Q2=141 (input scale)\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 22]), label=\"Q2=1152\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 35]), label=\"Q2=5233\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 41]), label=\"Q2=10523\", lw=3)\nplot!(xaxis=:log, legend=:bottomleft, xlabel=\"x\",\n    ylabel=\"log10(cross section spline input)\", ylims=(-7, 5))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iaF_eP = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eP, Float64(iaF_eP));\nQCDNUM.ssp_s2fill(iaF_eP, input_xsecp, splint_params.rscut);\n\niaF_eM = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eM, Float64(iaF_eM));\nQCDNUM.ssp_s2fill(iaF_eM, input_xsecm, splint_params.rscut);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"spline = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        spline[ix, iq] = QCDNUM.dsp_funs2(iaF_eP, qcdnum_x_grid[ix],\n            qcdnum_qq_grid[iq], 1)\n    end\nend\n\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(spline[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n    xaxis=:log, yaxis=:log)","category":"page"},{"location":"forward_model/#Integrate-over-the-cross-section-spline-and-find-expected-events-numbers","page":"Forward model","title":"Integrate over the cross section spline and find expected events numbers","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Here, we neglect any possible contribution from systematic errors","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"nbins = size(xbins_M_begin)[1]\nIntXsec_eP = zeros(nbins);\nIntXsec_eM = zeros(nbins);\nfor i in 1:nbins\n    IntXsec_eP[i] = QCDNUM.dsp_ints2(iaF_eP, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318.0, 4)\n    IntXsec_eM[i] = QCDNUM.dsp_ints2(iaF_eM, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318.0, 4)\nend","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"1 for e-p and 0 for e+p","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"ePp = 0;\neMp = 1;\n\nTM_eP = get_TM_elements(ePp);\nTM_eM = get_TM_elements(eMp);\n\nK_eP = get_K_elements(ePp);\nK_eM = get_K_elements(eMp);\n\nnbins_out = size(TM_eP)[2];\n\ncounts_pred_eP = zeros(nbins_out);\ncounts_pred_eM = zeros(nbins_out);\n\nfor j in 1:nbins_out\n\n    for i in 1:nbins\n\n        counts_pred_eP[j] += TM_eP[i, j] * (1.0 / K_eP[i]) * IntXsec_eP[i]\n        counts_pred_eM[j] += TM_eM[i, j] * (1.0 / K_eM[i]) * IntXsec_eM[i]\n\n    end\n\nend\n\ncounts_pred_eM","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Bayesian approach to parton density extraction. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hadrons, such as protons and neutrons, are made up of quarks held together by the strong force. At high energy scales, the valence quarks that define these hadrons exist in a sea of virtual quarks and gluons. The parton distribution functions (PDFs) describe this structure and are of fundamental importance to our understanding of quantum chromodynamics (QCD), as well as its application to LHC physics and the development of cosmic ray air showers in the Earth's atmosphere. PDFs can be extracted from accelerator measurements in which hadrons are probed through collisions with electrons. A limitation of existing approaches to analysing this data is the reliance on the chi-square statistic and the coupled assumption of Normal-distributed observations. We are working on a new statistical method for PDF extraction, which overcomes this limitation by forward modelling the problem from an input PDF to the expected number of events in a detector. This model will then be fit using Markov Chain Monte Carlo to enable inference of the PDF parameters. Our project builds on the QCDNUM software for fast QCD evolution and the Bayesian Analysis Toolkit for inference. We initially focus on the \"high-x\" regime and data from the ZEUS experiment, where the chi-square method cannot be used due to low event numbers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses QCDNUM.jl for fast PDF evolution and cross-section calculation and BAT.jl for Bayesian inference.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PartonDensity.jl has been used in the following publication:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"arXiv:2209.06571","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install PartonDensity.jl, start Julia and run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/cescalara/PartonDensity.jl.git\")","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Check out the examples listed in these docs! The scripts can be found in the examples directory of the GitHub repository. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To run these docs, you can follow the steps used in the GitHub workflow. In particular, we need to remember to use the latest versions of BAT.jl from GitHub. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/bat/BAT.jl.git\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to convert the example scripts to notebooks, use Literate.jl.","category":"page"},{"location":"#Development","page":"Introduction","title":"Development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Below are the installation instruction for those who wish to contribute to the code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Clone the github repository, e.g. via the command line:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone  https://github.com/cescalara/PartonDensity.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Enter the directory and start Julia interpreter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"cd PartonDensity.jl\njulia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Open the Julia package management environment pressing ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Execute ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> generate PartonDensity\n...... \npkg>  . dev","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Exit the package manager using backspace or pressing Ctrl+C","category":"page"}]
}
